#ifndef __TIMER_H__
#define __TIMER_H__
#include<8052.h>

// 我用的c51 是 11.0592MHz 的晶振,所以一次计数是 1秒/11.0592MHz = 0.08692 us
// 如果想要 1ms 产生一次中断,即需要 1ms/0.08692us = 11505
// 所以, 定时器0的重装值应为 65536-11505 = 54031 = 0xD30F
void TIMER_0_Init()
{
    // 每 1 ms 产生一次中断
    TMOD&= 0xF0;  // 清除定时器 0 的控制位
    TMOD |= 0x08; // 定时器 0 在模式 1 下用做计数器
    TH0 =  0xD3;       // 从64536 开始计数,设置计数值的高位
    TL0 =  0x0F;   // 设置计数值的低位
    TR0 = 1;  // 启动定时器1
    EA = 1;       // 开启总中断
    ET0 = 1;      // 定时器 0 的中断使能位
}

void TIMER_1_Init()
{
    // 定时器1, 不产生中断, 只用于产生波特率
    // AUXR &= 0x7F;    // 定时器1时钟为Fosc/12,即 921.6KHz              // AUXR 在51单片机上没有用,因为51单片机是最简单的,不需要做这个设置
    // AUXR &= 0xFE;    // 串口1选择定时器1的溢出标志作为波特率发生器的溢出标志
    TMOD &= 0x0F; // 清除定时器 1 的控制位, 保留低4位.51单片机串口通讯必须使用定时器1,不能使用定时器0
    TMOD |= 0x20; // 选择定时器1,工作方式2,即 8位自动重装,可以提高定时器的精度
    TH1 = 0xFA;   // 重装值, 波特率为 4800bps
    TL1 = 0xFA;   // 初始值
    TR1 = 1;      // 启动定时器1
}
/**
 * @brief 延时函数,使用 定时器 0 延时 ms 毫秒
 * @param ms
 */
void delay(unsigned int ms)
{
    for (int i = 0; i < ms; i++)
    {
        TIMER_0_Init();
        while (TF0 == 0)
            ;    // 计数器溢出时,时间刚好是1ms
        TR0 = 0; // 停止定时器 0
        TF0 = 0; // 清除定时器的溢出标志位
    }
}
#endif