#ifndef __UART_H__
#define __UART_H__
#include <8052.h>
// 我们使用同步方式,它是指通信双方在通信前都需要确定好通信的波特率.
// 同步移位方式的优点是传输速度快，缺点是需要额外的时钟信号线，并且通信双方的波特率需要事先约定,并必须保持一致.
// 异步方式是指通信双方在通信过程中不需要时钟信号，而是通过数据帧中的起始位和停止位来同步数据的传输。异步方式的优点是不需要额外的时钟信号线，缺点是传输速度比较慢。
// 一般来说，如果需要传输大量数据或者对数据传输的速度要求较高，可以使用同步方式。如果只是传输少量数据或者对数据传输的速度要求不是很高，可以使用异步方式。
// 因为我用的开发板是11.0592MHz的晶振 ,所以一次计数是 1秒/11.0592MHz = 0.08692 us
// 如果想要波特率为 4800bps , 即需要 1/4800 = 0.0002083s = 208.3us
// 那么 208.3us/0.08692us = 2400
// 所以, 定时器1的重装值为 65536-2400 = 63136 = 0xF700
// 工作方式0：串口作为同步移位寄存器使用，数据从RXD端输入或输出，同步移位脉冲由TXD端送出。发送和接收的数据均为8位，低位在前，高位在后。此方式通常用于扩展I/O口。
void UART_init(){   //4800bps@11.0592
    SCON = 0x50;    // SCON=01010000B，串口工作方式1，允许串口接收
    PCON = 0x00;    // SMOD=0，波特率不加倍
    IE = 0x90;      // 允许串口中断,通过中断方式接收数据

    // 定时器1, 不产生中断, 只用于产生波特率
    // AUXR &= 0x7F;    // 定时器1时钟为Fosc/12,即 921.6KHz              // AUXR 在51单片机上没有用,因为51单片机是最简单的,不需要做这个设置
    // AUXR &= 0xFE;    // 串口1选择定时器1的溢出标志作为波特率发生器的溢出标志
    TMOD &= 0x0F;   // 清除定时器 1 的控制位, 保留低4位.51单片机串口通讯必须使用定时器1,不能使用定时器0
    TMOD |= 0x20;    // 选择定时器1,工作方式2,即 8位自动重装,可以提高定时器的精度
    TH1 = 0xFA;     // 重装值, 波特率为 4800bps
    TL1 = 0xFA;     // 初始值
    ET1 = 0;        // 不需要定时器中断
    TR1 = 1;        // 启动定时器1


}


void UART_send(unsigned char byte) // 通过查询方式来发送数据
{
    SBUF = byte;    // 向缓存器中写入内容
    while(TI==0);   // 发送中,TI位 如果为0 就表示数据未发送完成.反复执行本条语句检测TI位
    TI = 0;         // 此时数据已发送完成, 马上将TI位清零,以便下一次发送.
}
#endif